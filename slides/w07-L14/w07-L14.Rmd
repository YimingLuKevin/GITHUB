---
title: "Iteration"
subtitle: "<br><br> Introduction to Data Science"
author: "University of Edinburgh"
date: "<br> 2024/2025"
output:
  xaringan::moon_reader:
    css: ["./xaringan-themer.css", "./slides.css"]
    lib_dir: libs
    anchor_sections: FALSE
    nature:
      ratio: "16:9"
      highlightLines: true
      highlightStyle: solarized-light
      countIncrementalSlides: false
---



```{r packages, echo = FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(rvest)
library(DT)
library(xaringanExtra)
xaringanExtra::use_panelset()
```

class: middle

# Iterations

- For loop
- While loop
- Mapping

---


## For loops in R

- The `for` loop will iterate the expression through the number of components in `values` (a vector or list) one at a time.
- It is an entry controlled loop, in this loop the **values** are tested first, then the **body of the loop is executed** in each of the values.

R – For loop Syntax:
```{r,eval=FALSE}
for (<index> in <values>) {
  
  # do something 
  
}
```
---

#Example 1 - with a sequence

.pull-left[
```{r,echo=TRUE}
for (i in 1:10){
  
  print(5*i)

  }
```
]
.pull-right[
Narrative:
- START. 
- Set the loop values as the sequence<br> `1 2 3 4 ... 10`
- Set index `i` to the 1st value, `1`
- Compute `5*i` and print.
- Set `index` to the next value, `2`
- Compute `5*i` and print.
- Set `index` to the next value, `3`
- ... (continue) ...
- Set `index` to the next value, `10`
- Compute `5*i` and print.
- Reached end of the values. 
- END.
]
---

#Example 2 - with a general vector

```{r,echo=TRUE}
# Create a vector with the days of the week
week <- c('Sunday', 'Monday', 'Tuesday', 'Wednesday', 
          'Thursday', 'Friday', 'Saturday')
 
# using for loop to iterate over the values in the vector
for (day in week) {
     # displaying each string in the vector
    print(day)
}
```

---

# Generalising - `seq_len(n)`

.pull-left[
* Creates a sequence from `1` to `n`.
* An alternative method to `1:n`.
* Example:
```{r}
seq_len(6)   # same as 1:6
```

```{r}
n <- 5
for(i in seq_len(n)){
  print(LETTERS[i])
}
```

]

.pull-right[
- Useful for catching unexpected behaviour
```{r}
seq_len(0)  # an empty vector
```

```{r}
# Bad example
n <- 0
for(i in 1:0) print(LETTERS[i])

# Good example
n <- 0
for(i in seq_len(n)) print(LETTERS[i])
```

]

---

# Generalising - `seq_along(x)`

.pull-left[
* Creates an index sequence based on the input `x`

* Example:
```{r}
week <- c('Sun', 'Mon', 'Tues', 'Wed', 
          'Thurs', 'Fri', 'Sat')
seq_along(week)
```
]

.pull-right[
```{r}
week <- c('Sun', 'Mon', 'Tues', 'Wed', 
          'Thurs', 'Fri', 'Sat')
#Compute number of characters in each string

#Set-up blank vector to store calculations
num_char <- rep(0L, length(week))
for(i in seq_along(week)){
  #Do calc. for i-th weekday
  num_char[i] <- nchar(week[i])
}
num_char
```

```{r}
nchar(week)
```
]

---

class: middle

# While loop



---

## While loops in R


- The `while` loop will iterate the expression as long as a logical test continues to return `TRUE`.
- In this loop the **test condition** is tested first, then the **body of the loop is executed**, the loop body would not be executed if the test condition is false.

R – While loop Syntax:
```{r,eval=FALSE}
while (<condition>) {
  
  #statement
  
}
```
---

#Example 1 - for loop as while loop

.pull-left[
```{r, echo=TRUE}
i <- 0
while (i < 10){
  print(5 * i)
  i <- i + 1
}
```
]
.pull-right[
Narrative:
* Initialise `i` with `0`
* Enter while loop
* TEST: `i < 10` = `0 < 10` = `TRUE`
* Compute `5*i` and print
* Iterate, add `1` to `i` & re-assign
* TEST: `i < 10` = `1 < 10` = `TRUE`
* Compute `5*i` and print
* Iterate, add `1` to `i` & re-assign
* ... (continue) ...
* TEST: `i < 10` = `10 < 10` = `FALSE`
* Exit while loop
]

---

#Example 2

Program to calculate factorial of a number.

.pull-left[
```{r,echo=TRUE}
# create variable whose 
# factorial will be calculated
n <- 5
# assigning the factorial variable
# and iteration variable to 1
fact <- 1
i <- 1
 
# using while loop
while (i <= n)
{
 
    # multiplying the factorial variable
    # with the iteration variable
    fact = fact * i
 
    # add one iteration 
    i = i + 1
}
```
]
.pull-right[
```{r,echo=TRUE}

# displaying the factorial
fact
```


```{r,echo=TRUE}
# Check with factorial() command
factorial(5)
```


]


---


# Caution! Infinite loops


.pull-left[
```{r, echo=TRUE , eval = FALSE}
i <- 0
while (i < 10){
  print(5 * i)
  i <- i - 1  #<<
}
```

```{r echo = FALSE}
for(i in 0:-20){
  print(5*i)
}
```

]
.pull-right[
Narrative:
* Initialise `i` with `0`
* Enter while loop
* TEST: `i < 10` = `0 < 10` = `TRUE`
* Compute `5*i` and print
* Update `i` (`i = -1`)
* TEST: `i < 10` = `-1 < 10` = `TRUE`
* Compute `5*i` and print
* Update `i` (`i = -2`)
* ... (continue) ...
* ... (FOR EVER!) ...
* .small[... (AND EVER!) ...]
* .small[... (AND EVER!) ...]
* .tiny[... (AND EVER!) ...]
* .tiny[... (AND EVER!) ...]
]



---
# Main differences between for and while loop.

- For loop is used when the number of iterations a code should be run is **known** where a while loop is used when the number of iterations is **not known**.

- `while` loops can potentially result in infinite loops if not written properly.

- In `for` loop the initialization once done is never repeated.

- In `while` loop the initialization is done each time the loop iterate.

- If you accidental create an infinite `while` loop, either:
  - Press the `Esc` key to stop all computation, or
  - Click on the stop button, 🟥 (for code chunk) or 🛑 (for console/viewer panels)

---

# Maclaurin series of $\sin(x)$

$$\sin(x) = \sum_{n = 0}^\infty \frac{(-1)^n}{(2n+1)!} x^{2n+1}, \quad\quad \sin\left(\frac{\pi}{4}\right) = \frac{1}{\sqrt{2}} \approx 0.7071$$
.pull-left[
```{r eval = FALSE, echo = TRUE}
x <- pi/4    
answer <- 0  # initialise answer
n <- 0       # initialise index
while(answer != (1/sqrt(2))){
  # Calculate and add n-th term
  answer <- answer + 
    x^(2*n+1) * (-1)^n / factorial(2*n + 1)
  
  #print partial sum
  print(answer)

  #iterate index
  n <- n + 1
}

```
]


.pull-right[
```{r eval = TRUE, echo = FALSE}
x <- pi/4    
answer <- 0  # initialise answer
n <- 0       # initialise index
while(answer != (1/sqrt(2))){
  # Calculate and add n-th term
  answer <- answer + 
    x^(2*n+1) * (-1)^n / factorial(2*n + 1)
  
  #print partial sum
  print(answer)

  #iterate index
  n <- n + 1
}
```

```{r}
answer
```
]

---

# Maclaurin series of $\sin(x)$

$$\sin(x) = \sum_{n = 0}^\infty \frac{(-1)^n}{(2n+1)!} x^{2n+1}, \quad\quad \sin\left(\frac{\pi}{8}\right) = \frac{\sqrt{2-\sqrt{2}}}{2} \approx 0.3827$$

.pull-left[
```{r echo = TRUE, eval = FALSE}
x <- pi/8    
answer <- 0  # initialise answer
n <- 0       # initialise index
while(answer != sqrt(2-sqrt(2))/2){
  # Calculate and add n-th term
  answer <- answer + 
    x^(2*n+1) * (-1)^n / factorial(2*n + 1)
  
  #print partial sum
  print(answer)
  
  #iterate index
  n <- n + 1
}
```
]

.pull-right[
```{r echo = FALSE, eval = TRUE}
x <- pi/8    # sin(pi/8) = sqrt(2-sqrt(2))/2 ~= 0.3827

answer <- 0  # initialise answer
n <- 0       # initialise index
while(answer != sqrt(2-sqrt(2))/2 | n <= 30){
  # Calculate and add n-th term
  new_term <- x^(2*n+1) * (-1)^n / factorial(2*n + 1)
  answer <- answer + new_term
  
  #print partial sum
  print(answer)
  
  #iterate index
  n <- n + 1
}
```
]

---

## Unexpected behavour with floating point numbers

.pull-left[
```{r, echo=TRUE}
#EXAMPLE 1
2/7 + 3/7 + 2/7
2/7 + 3/7 + 2/7 == 1
2/7 + 3/7 + 2/7 - 1

```
]
.pull-right[
```{r, echo=TRUE}
#EXAMPLE 2
1 + 10^(-16) == 1
10^(-16) 
.Machine$double.eps
```
]


---


## Use a **tolerance** value.


```{r, echo=TRUE}
#EXAMPLE 1
2/7 + 3/7 + 2/7 == 1

tolerance <- 10^-16  #Something you consider small. 

2/7 + 3/7 + 2/7 - 1 < tolerance

tolerance <- .Machine$double.eps #The machine epsilon

2/7 + 3/7 + 2/7 - 1 < tolerance

```


---

##Example

```{r, echo=TRUE}

j <- 0
while (j < 1) { j <- j+0.1 }; j
j <- 0
j + .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1
j + .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1 < 1

j <- 0
tolerance <- 10^-16 
while (j  < 1 - tolerance) { j <- j+0.1 }; j

```


---

# Maclaurin series of $\sin(x)$ - revisited

* Exit condition: The difference between iterations is smaller than some threshold.

.pull-left[
```{r echo = TRUE, eval = FALSE}
x <- pi/8    
answer <- 0   
n <- 0        
prev_step <- 1       #<<
tol <- 10^(-16)   #<<
while(abs(answer-prev_step) > tol){
  # Store last value
  prev_step <- answer  #<<
  
  # Calculate and add n-th term
  answer <- answer + 
    x^(2*n+1) * (-1)^n / factorial(2*n + 1)
  
  #print partial sum
  print(answer)
  
  #iterate index
  n <- n + 1
}
```
]

.pull-right[
```{r echo = FALSE, eval = TRUE}
x <- pi/8    
answer <- 0   
n <- 0        
prev_step <- 1       #<<
epsilon <- 10^(-16)   #<<
while(abs(answer-prev_step) > epsilon){
  # Store last value
  prev_step <- answer  #<<
  
  # Calculate and add n-th term
  answer <- answer + 
    x^(2*n+1) * (-1)^n / factorial(2*n + 1)
  
  #print partial sum
  print(answer)
  
  #iterate index
  n <- n + 1
}
```

```{r}
answer
```
]

---

class: middle

# Mapping: 
## To loop or not to loop, that is the question! 

---

## Avoiding Explicit Loops 

Suppose we have exam 1 and exam 2 scores of 10 students stored in a list...

```{r}
exam_scores <- list(
  exam1 <- c(80, 90, 70, 50, 80, 40, 90, 95, 80, 90),
  exam2 <- c(85, 83, 45, 60, 85, 95, 40, 75, 90, 85)
)
```

Calculate the mean of exam 1 and exam 2 using a loop:

```{r, echo=TRUE}

m <- numeric()
for (i in 1:length(exam_scores)){
  m[i] <- mean(exam_scores[[i]])
}
m

```

Can we make the R code both simpler and more efficient?


---

## `map_something`

Functions for looping over an object and returning a value (of a specific type):

* `map()` - returns a list
* `map_lgl()` - returns a logical vector
* `map_int()` - returns a integer vector
* `map_dbl()` - returns a double vector
* `map_chr()` - returns a character vector
* `map_df()` / `map_dfr()` - returns a data frame by row binding
* `map_dfc()` - returns a data frame by column binding
* ...

---

## How does mapping work?

Suppose we have `exam1` and `exam2` scores of 10 students stored in a list...

```{r}
exam_scores <- list(
  exam1 <- c(80, 90, 70, 50, 80, 40, 90, 95, 80, 90),
  exam2 <- c(85, 83, 45, 60, 85, 95, 40, 75, 90, 85)
)
```


...and we find the mean score in each exam

```{r}
map(exam_scores, mean)
```

---

## Comparing execution times ⏱

.pull-left[
* Via looping
```{r,echo=TRUE}
start.time <- Sys.time()
m <- numeric()
for (i in seq_along(exam_scores)){
  m[i] <- mean(exam_scores[[i]])
}
m
end.time <- Sys.time()
end.time - start.time
```
]
.pull-right[
* Via mapping
```{r,echo=TRUE}
start.time <- Sys.time()
map_dbl(exam_scores, mean)
end.time <- Sys.time()
end.time - start.time
```
]
---

## A bigger example

```{r echo=FALSE}
set.seed(123)
```


.panelset[

.panel[.panel-name[code]

Simulate data for 10 exams for 100 students.
```{r,echo=TRUE}
num_students <- 100
possible_marks <- 0:100
exam_scores <- list(
  exam1  = sample(x = possible_marks, size = num_students, replace = TRUE),
  exam2  = sample(x = possible_marks, size = num_students, replace = TRUE),
  exam3  = sample(x = possible_marks, size = num_students, replace = TRUE),
  exam4  = sample(x = possible_marks, size = num_students, replace = TRUE),
  exam5  = sample(x = possible_marks, size = num_students, replace = TRUE),
  exam6  = sample(x = possible_marks, size = num_students, replace = TRUE),
  exam7  = sample(x = possible_marks, size = num_students, replace = TRUE),
  exam8  = sample(x = possible_marks, size = num_students, replace = TRUE),
  exam9  = sample(x = possible_marks, size = num_students, replace = TRUE),
  exam10 = sample(x = possible_marks, size = num_students, replace = TRUE)
)
```
]

.panel[.panel-name[glimpse]
```{r eval=TRUE}
glimpse(exam_scores)
```
]
]
---

## Comparing execution times ⏱

.pull-left[
* Via looping
```{r,echo=TRUE,R.options=list(width = 40)}
start.time <- Sys.time()
m <- numeric()
for (i in seq_along(exam_scores)){
  m[i] <- mean(exam_scores[[i]])
}
m
end.time <- Sys.time()
end.time - start.time
```
]
.pull-right[
* Via mapping
```{r,echo=TRUE,R.options=list(width = 40)}
start.time <- Sys.time()
map_dbl(exam_scores, mean)
end.time <- Sys.time()
end.time - start.time
```
]

